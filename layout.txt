REFINED (Mini seeq clone)

Functionality:
Upload real-time process data into program using multiple tags
Search those tags to trend data
Detect anomalies within that data and generate reports

Flow:
User uploads CSV file with timestamps and values for individual tags -> insert data into SQLite3 database -> show data

To do:
Build system
Build script to generate pseudo process data
Build script to read data into python

Stack:
Backend - FastAPI (Python)
Frontend - HTMX/HTML/Tailwind/CSS
Database - SQLite
Plotting - Plotly

REFINED/
├── app.py                      # FastAPI app
├── database.py                 # SQLite functions
├── generate_sample_data.py     # Sample data generator
├── requirements.txt            # Dependencies
├── templates/
│   └── index.html              # Main page
└── README.md 

Current status:
Last updated: 12/09/2025 20:53

Completed:
Wrote functionality to read .csv sample file into SQL database using pandas dataframe
Wrote rudimentary HTMX to receive and pass to /get-tag-id endpoint to fetch data and plot
Wrote fxn to read sql database for tag id and collect data
Passed that data to plotly to create interactive charts
Return plotly as HTML, regenerate all plots each time a tag is queried
Used claude to generate flexbox css
Added dare range changinf functionality
Wrote script to add more datapoints to CSV
Made all of the time manipulation buttons call their own endpoints
Added functionality for buttons to skip to present and oldest points in the data.csv file
Added functionality for buttons to skip forward and backward by current timeframe, handled out of bounds edge cases
Built lark grammar and class
Made get_df function to grab df object of existing tags needed to execute formulas to create new tags

Next steps:
Allow tags to be in same graph
Allow tags to be in same y axis
Add more fxns


Bugs:
Fix buttons
Parser edge cases (a lot)

Future:
Make data insertion fxn async
Make time columns for each individual tag
Edge cases/polish grammar

Claude code review:
Inconsistent error handling: Sometimes uses try-except blocks, sometimes doesn't. When they do use them, the exception handling is often too broad (except Exception as e)
Global variables: Uses plot_count and current_plots as globals in app.py rather than using proper state management
SQL injection awareness but incomplete implementation: Has a regex check for tag_id format to prevent SQL injection, but then uses f-strings for SQL queries anyway (which negates the protection)
Commented-out code left in: The bottom of execute_formula() has commented-out code that should have been removed
Redundant database connections: Opens SQLite connections at module level rather than using connection pooling or context managers consistently
Mixed naming conventions: Some functions use snake_case consistently, but there's inconsistency in how things are organized




